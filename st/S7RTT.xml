<?xml version="1.0" encoding="utf-8"?>
<project xmlns="http://www.plcopen.org/xml/tc6_0200">
  <fileHeader companyName="" productName="CODESYS" productVersion="CODESYS V3.5 SP20" creationDateTime="2025-12-01T11:44:53.1277508" />
  <contentHeader name="S7RTT.project" modificationDateTime="2025-12-01T09:40:39.1420978">
    <coordinateInfo>
      <fbd>
        <scaling x="1" y="1" />
      </fbd>
      <ld>
        <scaling x="1" y="1" />
      </ld>
      <sfc>
        <scaling x="1" y="1" />
      </sfc>
    </coordinateInfo>
    <addData>
      <data name="http://www.3s-software.com/plcopenxml/projectinformation" handleUnknown="implementation">
        <ProjectInformation />
      </data>
    </addData>
  </contentHeader>
  <types>
    <dataTypes>
      <dataType name="ST_MotionLimits">
        <baseType>
          <struct>
            <variable name="fVelMax">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="fAccMax">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="fJerkMax">
              <type>
                <LREAL />
              </type>
            </variable>
          </struct>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>d3412a66-ab42-4656-b5ac-8ceac29439de</ObjectId>
          </data>
        </addData>
      </dataType>
      <dataType name="ST_MotionState">
        <baseType>
          <struct>
            <variable name="fDuration">
              <type>
                <LREAL />
              </type>
              <initialValue>
                <simpleValue value="0.0" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> Duration of this segment </xhtml>
              </documentation>
            </variable>
            <variable name="fPos">
              <type>
                <LREAL />
              </type>
              <initialValue>
                <simpleValue value="0.0" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> Position </xhtml>
              </documentation>
            </variable>
            <variable name="fVel">
              <type>
                <LREAL />
              </type>
              <initialValue>
                <simpleValue value="0.0" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> Velocity </xhtml>
              </documentation>
            </variable>
            <variable name="fAcc">
              <type>
                <LREAL />
              </type>
              <initialValue>
                <simpleValue value="0.0" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> Acceleration </xhtml>
              </documentation>
            </variable>
            <variable name="fJerk">
              <type>
                <LREAL />
              </type>
              <initialValue>
                <simpleValue value="0.0" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> Jerk </xhtml>
              </documentation>
            </variable>
          </struct>
        </baseType>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>093654ef-94b9-49f9-9c6c-4acf457e8661</ObjectId>
          </data>
        </addData>
      </dataType>
    </dataTypes>
    <pous>
      <pou name="FB_S7RTT_OTG" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="ControlInterface">
              <type>
                <BOOL />
              </type>
              <initialValue>
                <simpleValue value="FALSE" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">false=position, true=velocity</xhtml>
              </documentation>
            </variable>
            <variable name="TargetPosition">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="TargetVelocity">
              <type>
                <LREAL />
              </type>
              <initialValue>
                <simpleValue value="0" />
              </initialValue>
            </variable>
            <variable name="CycleTime">
              <type>
                <LREAL />
              </type>
              <initialValue>
                <simpleValue value="0.001" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">1ms</xhtml>
              </documentation>
            </variable>
            <variable name="MaxVelocity">
              <type>
                <LREAL />
              </type>
              <initialValue>
                <simpleValue value="10" />
              </initialValue>
            </variable>
            <variable name="MaxAcceleration">
              <type>
                <LREAL />
              </type>
              <initialValue>
                <simpleValue value="10" />
              </initialValue>
            </variable>
            <variable name="MaxJerk">
              <type>
                <LREAL />
              </type>
              <initialValue>
                <simpleValue value="10" />
              </initialValue>
            </variable>
            <variable name="CurrentPosition">
              <type>
                <LREAL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml">set when init</xhtml>
              </documentation>
            </variable>
          </inputVars>
          <outputVars>
            <variable name="NewPosition">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="NewVelocity">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="NewAcceleration">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="xError">
              <type>
                <BOOL />
              </type>
            </variable>
          </outputVars>
          <localVars>
            <variable name="_ControlInterface">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="_TargetPosition">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="_TargetVelocity">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="_CycleTime">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="_MaxVelocity">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="_MaxAcceleration">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="_MaxJerk">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="_CurrentPosition">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="xExecute">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="fbS7Planner">
              <type>
                <derived name="FB_S7RTT_Plan" />
              </type>
            </variable>
            <variable name="stS7Limits">
              <type>
                <derived name="ST_MotionLimits" />
              </type>
            </variable>
            <variable name="stS7Start">
              <type>
                <derived name="ST_MotionState" />
              </type>
            </variable>
            <variable name="stS7Result">
              <type>
                <derived name="ST_MotionState" />
              </type>
            </variable>
            <variable name="fS7Timer">
              <type>
                <LREAL />
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">// check if input changed
IF (ControlInterface &lt;&gt; _ControlInterface) OR
	(TargetPosition &lt;&gt; _TargetPosition) OR
	(TargetVelocity &lt;&gt; _TargetVelocity) OR
	(CycleTime &lt;&gt; _CycleTime) OR
	(MaxVelocity &lt;&gt; _MaxVelocity) OR
	(MaxAcceleration &lt;&gt; _MaxAcceleration) OR
	(MaxJerk &lt;&gt; _MaxJerk) OR
	(CurrentPosition &lt;&gt; _CurrentPosition) THEN
	
	IF CurrentPosition &lt;&gt; _CurrentPosition THEN
		stS7Start.fPos := CurrentPosition;
		stS7Result.fPos := CurrentPosition;
		_CurrentPosition := CurrentPosition;
	END_IF
	_ControlInterface := ControlInterface;
	_TargetPosition := TargetPosition;
	_TargetVelocity := TargetVelocity;
	_CycleTime := CycleTime;
	_MaxVelocity := MaxVelocity;
	_MaxAcceleration := MaxAcceleration;
	_MaxJerk := MaxJerk;
	
	xExecute:=TRUE;
END_IF

// main logic
IF xExecute THEN
    stS7Start.fPos := stS7Result.fPos;
    stS7Start.fVel := stS7Result.fVel;
    stS7Start.fAcc := stS7Result.fAcc;
    stS7Start.fDuration := 0.0;
    
    stS7Limits.fVelMax := MaxVelocity;
    stS7Limits.fAccMax := MaxAcceleration;
    stS7Limits.fJerkMax := MaxJerk;
    
    fbS7Planner.ModeVelocity := ControlInterface;
    fbS7Planner.StartState := stS7Start;
    fbS7Planner.TargetPos := TargetPosition;
    fbS7Planner.TargetVel := TargetVelocity; 
    fbS7Planner.Limits := stS7Limits;
    
    fS7Timer := 0.0;
END_IF

fbS7Planner(Execute:=xExecute,Error=&gt;xError);

xExecute := FALSE;

fS7Timer := fS7Timer + CycleTime;

stS7Result := FC_S7RTT_AtTime(
	Trajectory := fbS7Planner.Trajectory, 
	SegCount := fbS7Planner.SegmentCount, 
	ElapsedTime := fS7Timer
);

NewPosition:=stS7Result.fPos;
NewVelocity:=stS7Result.fVel;
NewAcceleration:=stS7Result.fAcc;


</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>a4ba0152-5153-418a-8491-262185d3062f</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="FB_S7RTT_Plan" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="Execute">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="ModeVelocity">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="StartState">
              <type>
                <derived name="ST_MotionState" />
              </type>
            </variable>
            <variable name="TargetPos">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="TargetVel">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="Limits">
              <type>
                <derived name="ST_MotionLimits" />
              </type>
            </variable>
          </inputVars>
          <outputVars>
            <variable name="Done">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="Error">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="SegmentCount">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="Trajectory">
              <type>
                <array>
                  <dimension lower="1" upper="32" />
                  <baseType>
                    <derived name="ST_MotionState" />
                  </baseType>
                </array>
              </type>
            </variable>
          </outputVars>
          <localVars>
            <variable name="trig_exec">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> State &amp; Triggers</xhtml>
              </documentation>
            </variable>
            <variable name="prev_exec">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="c_pos">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="c_vel">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="c_acc">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="i">
              <type>
                <INT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> Loop Iterators</xhtml>
              </documentation>
            </variable>
            <variable name="k">
              <type>
                <INT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> Loop Iterators</xhtml>
              </documentation>
            </variable>
            <variable name="dist_req">
              <type>
                <LREAL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> General Calculation</xhtml>
              </documentation>
            </variable>
            <variable name="t_rec">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="gap">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="d_upper">
              <type>
                <LREAL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> Check Bounds</xhtml>
              </documentation>
            </variable>
            <variable name="d_lower">
              <type>
                <LREAL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> Check Bounds</xhtml>
              </documentation>
            </variable>
            <variable name="t_cruise">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="iter">
              <type>
                <INT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> --- Solver Shared Variables ---</xhtml>
              </documentation>
            </variable>
            <variable name="sa">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="sb">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="sc">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="fa">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="fb">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="fc">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="sd">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="se">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="tol1">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="xm">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="min1">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="min2">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="fCoefP">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="fCoefQ">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="fCoefR">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="fCoefS">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="mflag">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="use_optimal">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> --- V1.7 Time Optimal Specific ---</xhtml>
              </documentation>
            </variable>
            <variable name="opt_success">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="j_idx">
              <type>
                <INT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> 0 or 1</xhtml>
              </documentation>
            </variable>
            <variable name="j_apply">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="search_horizon">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="t_est">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="sim_p">
              <type>
                <LREAL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> Simulation / Cost Function Vars</xhtml>
              </documentation>
            </variable>
            <variable name="sim_v">
              <type>
                <LREAL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> Simulation / Cost Function Vars</xhtml>
              </documentation>
            </variable>
            <variable name="sim_a">
              <type>
                <LREAL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> Simulation / Cost Function Vars</xhtml>
              </documentation>
            </variable>
            <variable name="limit_a">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="dist_to_lim">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="t_ramp">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="t_hold">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="sat_dt">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="sat_j">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="valid_curr">
              <type>
                <BOOL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> Best Candidate Tracking</xhtml>
              </documentation>
            </variable>
            <variable name="best_t_curr">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="dur_curr">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="winner_found">
              <type>
                <BOOL />
              </type>
            </variable>
            <variable name="winner_dur">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="winner_t">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="winner_j">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="best_v">
              <type>
                <LREAL />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> --- Fallback / Old Variables ---</xhtml>
              </documentation>
            </variable>
            <variable name="v_mid">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="a_mid">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="v_inertial">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="d_inertial">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="t_to_zero">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="j_restore">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="t_shape_buf">
              <type>
                <array>
                  <dimension lower="1" upper="5" />
                  <baseType>
                    <LREAL />
                  </baseType>
                </array>
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> Buffers</xhtml>
              </documentation>
            </variable>
            <variable name="j_shape_buf">
              <type>
                <array>
                  <dimension lower="1" upper="5" />
                  <baseType>
                    <LREAL />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="shape_cnt">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="ref_idx">
              <type>
                <INT />
              </type>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> Refinement</xhtml>
              </documentation>
            </variable>
            <variable name="max_dt">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="dt_fix">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="v_cruise_start">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="EPS_TIME">
              <type>
                <LREAL />
              </type>
              <initialValue>
                <simpleValue value="1E-10" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> Constants (Updated V1.7)</xhtml>
              </documentation>
            </variable>
            <variable name="EPS_VAL">
              <type>
                <LREAL />
              </type>
              <initialValue>
                <simpleValue value="1E-10" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> Velocity Tolerance</xhtml>
              </documentation>
            </variable>
            <variable name="EPS_ACC">
              <type>
                <LREAL />
              </type>
              <initialValue>
                <simpleValue value="1E-10" />
              </initialValue>
            </variable>
            <variable name="EPS_DIST">
              <type>
                <LREAL />
              </type>
              <initialValue>
                <simpleValue value="1E-10" />
              </initialValue>
            </variable>
            <variable name="MATH_EPS">
              <type>
                <LREAL />
              </type>
              <initialValue>
                <simpleValue value="1E-10" />
              </initialValue>
            </variable>
            <variable name="SOLVER_TOL">
              <type>
                <LREAL />
              </type>
              <initialValue>
                <simpleValue value="1E-10" />
              </initialValue>
            </variable>
            <variable name="SOLVER_EPS">
              <type>
                <LREAL />
              </type>
              <initialValue>
                <simpleValue value="2.22E-16" />
              </initialValue>
            </variable>
            <variable name="SOLVER_COARSE">
              <type>
                <LREAL />
              </type>
              <initialValue>
                <simpleValue value="0.0001" />
              </initialValue>
              <documentation>
                <xhtml xmlns="http://www.w3.org/1999/xhtml"> For initial checks</xhtml>
              </documentation>
            </variable>
            <variable name="MAX_ITER">
              <type>
                <INT />
              </type>
              <initialValue>
                <simpleValue value="50" />
              </initialValue>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">// ==============================================================================
// File Name:    FB_S7RTT_Plan.st
// Author:       feecat
// Version:      V1.7.2
// Description:  Simple 7seg Real-Time Trajectory Generator
// Website:      https://github.com/feecat/S7RTT
// License:      Apache License Version 2.0
// ==============================================================================
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ==============================================================================

trig_exec := Execute AND NOT prev_exec;
prev_exec := Execute;

IF NOT Execute THEN
	Done := FALSE; Error := FALSE; RETURN;
END_IF

IF NOT trig_exec THEN RETURN; END_IF;

// --- Initialization ---
Done := FALSE;
Error := FALSE;
SegmentCount := 0;
opt_success := FALSE;

IF Limits.fVelMax &lt;= 0.0 OR Limits.fAccMax &lt;= 0.0 OR Limits.fJerkMax &lt;= 0.0 THEN
	Error := TRUE; RETURN;
END_IF;

c_pos := StartState.fPos; c_vel := StartState.fVel; c_acc := StartState.fAcc;

// ========================================================
// 1. Acceleration Recovery (Safety Decel)
// ========================================================
IF c_acc &gt; Limits.fAccMax + EPS_ACC THEN
	// Positive Saturation: Accel is too high positive, must reduce
	j_restore := -Limits.fJerkMax;
	limit_a := Limits.fAccMax;
	t_rec := (c_acc - limit_a) / (-j_restore);
	
	IF t_rec &gt; EPS_TIME THEN
		SegmentCount := SegmentCount + 1;
		Trajectory[SegmentCount].fDuration := t_rec;
		Trajectory[SegmentCount].fJerk     := j_restore;
		// Integ State
		c_pos := c_pos + c_vel * t_rec + 0.5 * c_acc * t_rec*t_rec + (1.0/6.0) * j_restore * t_rec*t_rec*t_rec;
		c_vel := c_vel + c_acc * t_rec + 0.5 * j_restore * t_rec*t_rec;
		c_acc := limit_a;
	END_IF;
	
ELSIF c_acc &lt; -Limits.fAccMax - EPS_ACC THEN
	// Negative Saturation: Accel is too low negative, must increase
	j_restore := Limits.fJerkMax;
	limit_a := -Limits.fAccMax;
	t_rec := (c_acc - limit_a) / (-j_restore); // Note: -j_restore here implies dividing by -JerkMax which is negative
	
	IF t_rec &gt; EPS_TIME THEN
		SegmentCount := SegmentCount + 1;
		Trajectory[SegmentCount].fDuration := t_rec;
		Trajectory[SegmentCount].fJerk     := j_restore;
		// Integ State
		c_pos := c_pos + c_vel * t_rec + 0.5 * c_acc * t_rec*t_rec + (1.0/6.0) * j_restore * t_rec*t_rec*t_rec;
		c_vel := c_vel + c_acc * t_rec + 0.5 * j_restore * t_rec*t_rec;
		c_acc := limit_a;
	END_IF;
END_IF;

// ========================================================
// 2. Plan Generation
// ========================================================
IF ModeVelocity THEN
	// --- Velocity Mode (Unchanged Logic, New Constants) ---
	v_mid := TargetVel; 
	IF v_mid &gt; Limits.fVelMax THEN v_mid := Limits.fVelMax; END_IF;
	IF v_mid &lt; -Limits.fVelMax THEN v_mid := -Limits.fVelMax; END_IF;

	shape_cnt := FC_S7RTT_BuildProfile(c_vel, c_acc, v_mid, Limits.fAccMax, Limits.fJerkMax, t_shape_buf, j_shape_buf);
	IF shape_cnt &gt; 0 THEN
		FOR i := 1 TO shape_cnt DO
			IF SegmentCount &lt; 32 THEN
				SegmentCount := SegmentCount + 1;
				Trajectory[SegmentCount].fDuration := t_shape_buf[i];
				Trajectory[SegmentCount].fJerk     := j_shape_buf[i];
			END_IF;
		END_FOR;
	ELSE
		FOR i := 1 TO 31 DO
			SegmentCount := SegmentCount + 1;
			Trajectory[SegmentCount].fDuration := 0;
			Trajectory[SegmentCount].fJerk     := 0;
		END_FOR;
	END_IF
ELSE
	// --- Position Mode ---
	dist_req := TargetPos - c_pos;

	// Capacity Check (Can we reach target without hitting velocity limits?)
	// Note: FC_S7RTT_CalcTrajDist returns distance traveled to reach TargetVel via +/- VelMax
	d_upper := FC_S7RTT_CalcTrajDist(Limits.fVelMax, c_vel, c_acc, TargetVel, Limits.fAccMax, Limits.fJerkMax);
	d_lower := FC_S7RTT_CalcTrajDist(-Limits.fVelMax, c_vel, c_acc, TargetVel, Limits.fAccMax, Limits.fJerkMax);

	// Decision: Cruise or Optimal?
	use_optimal := TRUE;
	IF dist_req &gt; d_upper + EPS_DIST THEN use_optimal := FALSE; END_IF;
	IF dist_req &lt; d_lower - EPS_DIST THEN use_optimal := FALSE; END_IF;

	// ========================================================
	// 2.1 Time Optimal Solver (New V1.7 Feature)
	// ========================================================
	IF use_optimal THEN
		winner_found := FALSE;
		winner_dur := 1.0E10; // Init Large
		
		// Estimate search horizon
		t_est := (ABS(c_vel) + Limits.fVelMax) / Limits.fAccMax;
		IF t_est &lt; 1.0 THEN t_est := 1.0; END_IF;
		search_horizon := t_est * 2.0 + 5.0;

		// Bidirectional Competition: Try +Jerk and -Jerk
		FOR j_idx := 0 TO 1 DO
			IF j_idx = 0 THEN j_apply := Limits.fJerkMax; ELSE j_apply := -Limits.fJerkMax; END_IF;
			valid_curr := FALSE;
			
			// Brent Solver Setup: Range [0, search_horizon]
			sa := 0.0; sb := search_horizon;
			
			// --- Evaluate at sa (0.0) ---
			// Inline Simulation Block 1
			sim_p := c_pos; sim_v := c_vel; sim_a := c_acc; // Reset State
			// Integrate Saturated (t=0 -&gt; no effect), then Build Profile
			shape_cnt := FC_S7RTT_BuildProfile(sim_v, sim_a, TargetVel, Limits.fAccMax, Limits.fJerkMax, t_shape_buf, j_shape_buf);
			FOR k:=1 TO shape_cnt DO 
				sim_p := sim_p + sim_v*t_shape_buf[k] + 0.5*sim_a*t_shape_buf[k]*t_shape_buf[k] + (1.0/6.0)*j_shape_buf[k]*t_shape_buf[k]*t_shape_buf[k]*t_shape_buf[k]; 
				sim_v := sim_v + sim_a*t_shape_buf[k] + 0.5*j_shape_buf[k]*t_shape_buf[k]*t_shape_buf[k];
				sim_a := sim_a + j_shape_buf[k]*t_shape_buf[k];
			END_FOR;
			fa := sim_p - TargetPos; // Error at t=0
			
			IF ABS(fa) &lt; SOLVER_COARSE THEN
				best_t_curr := 0.0; valid_curr := TRUE;
			ELSE
				// --- Evaluate at sb (horizon) ---
				// Inline Simulation Block 2
				sim_p := c_pos; sim_v := c_vel; sim_a := c_acc;
				limit_a := Limits.fAccMax; IF j_apply &lt; 0 THEN limit_a := -Limits.fAccMax; END_IF;
				dist_to_lim := limit_a - sim_a;
				IF (j_apply &gt; 0 AND dist_to_lim &gt; -MATH_EPS) OR (j_apply &lt; 0 AND dist_to_lim &lt; MATH_EPS) THEN t_ramp := dist_to_lim / j_apply; ELSE t_ramp := 0.0; END_IF;
				// Saturated Int (simplified logic for end of range)
				IF sb &lt;= t_ramp THEN
					sim_p:=sim_p+sim_v*sb+0.5*sim_a*sb*sb+(1.0/6.0)*j_apply*sb*sb*sb; sim_v:=sim_v+sim_a*sb+0.5*j_apply*sb*sb; sim_a:=sim_a+j_apply*sb;
				ELSE
					sim_p:=sim_p+sim_v*t_ramp+0.5*sim_a*t_ramp*t_ramp+(1.0/6.0)*j_apply*t_ramp*t_ramp*t_ramp; sim_v:=sim_v+sim_a*t_ramp+0.5*j_apply*t_ramp*t_ramp; sim_a:=sim_a+j_apply*t_ramp;
					sim_a:=limit_a; t_hold:=sb-t_ramp;
					sim_p:=sim_p+sim_v*t_hold+0.5*sim_a*t_hold*t_hold; sim_v:=sim_v+sim_a*t_hold;
				END_IF;
				shape_cnt := FC_S7RTT_BuildProfile(sim_v, sim_a, TargetVel, Limits.fAccMax, Limits.fJerkMax, t_shape_buf, j_shape_buf);
				FOR k:=1 TO shape_cnt DO sim_p:=sim_p+sim_v*t_shape_buf[k]+0.5*sim_a*t_shape_buf[k]*t_shape_buf[k]+(1.0/6.0)*j_shape_buf[k]*t_shape_buf[k]*t_shape_buf[k]*t_shape_buf[k]; sim_v:=sim_v+sim_a*t_shape_buf[k]+0.5*j_shape_buf[k]*t_shape_buf[k]*t_shape_buf[k]; sim_a:=sim_a+j_shape_buf[k]*t_shape_buf[k]; END_FOR;
				fb := sim_p - TargetPos;

				// Bounds Check
				IF fa * fb &lt;= 0.0 THEN
					// Brent Loop
					sc := sa; fc := fa; sd := sb - sa; se := sd; mflag := TRUE;
					FOR iter := 1 TO MAX_ITER DO
						IF ABS(fc) &lt; ABS(fb) THEN sa:=sb; sb:=sc; sc:=sa; fa:=fb; fb:=fc; fc:=fa; END_IF;
						tol1 := 2.0 * SOLVER_EPS * ABS(sb) + 0.5 * SOLVER_TOL; xm := 0.5 * (sc - sb);
						IF ABS(xm) &lt;= tol1 OR fb = 0.0 THEN EXIT; END_IF;
						IF ABS(se) &gt;= tol1 AND ABS(fa) &gt; ABS(fb) THEN
							fCoefS := fb / fa;
							IF sa = sc THEN fCoefP := 2.0*xm*fCoefS; fCoefQ := 1.0-fCoefS;
							ELSE fCoefQ := fa/fc; fCoefR := fb/fc; fCoefP := fCoefS*(2.0*xm*fCoefQ*(fCoefQ-fCoefR)-(sb-sa)*(fCoefR-1.0)); fCoefQ := (fCoefQ-1.0)*(fCoefR-1.0)*(fCoefS-1.0); END_IF;
							IF fCoefP &gt; 0.0 THEN fCoefQ := -fCoefQ; END_IF; fCoefP := ABS(fCoefP);
							min1 := 3.0*xm*fCoefQ - ABS(tol1*fCoefQ); min2 := ABS(se*fCoefQ);
							IF 2.0*fCoefP &lt; min1 THEN
								IF mflag THEN IF 2.0*fCoefP &lt; min2 THEN se:=sd; sd:=fCoefP/fCoefQ; mflag:=FALSE; ELSE sd:=xm; se:=sd; mflag:=TRUE; END_IF;
								ELSE IF 2.0*fCoefP &lt; ABS(sd*fCoefQ) THEN se:=sd; sd:=fCoefP/fCoefQ; mflag:=FALSE; ELSE sd:=xm; se:=sd; mflag:=TRUE; END_IF; END_IF;
							ELSE sd:=xm; se:=sd; mflag:=TRUE; END_IF;
						ELSE sd:=xm; se:=sd; mflag:=TRUE; END_IF;
						sa := sb; fa := fb;
						IF ABS(sd) &gt; tol1 THEN sb:=sb+sd; ELSE IF xm &gt; 0.0 THEN sb:=sb+tol1; ELSE sb:=sb-tol1; END_IF; END_IF;
						
						// --- Eval Function (t = sb) ---
						// Only necessary to update fb. Re-use simulation logic.
						sim_p := c_pos; sim_v := c_vel; sim_a := c_acc;
						limit_a := Limits.fAccMax; IF j_apply &lt; 0 THEN limit_a := -Limits.fAccMax; END_IF;
						dist_to_lim := limit_a - sim_a;
						IF (j_apply &gt; 0 AND dist_to_lim &gt; -MATH_EPS) OR (j_apply &lt; 0 AND dist_to_lim &lt; MATH_EPS) THEN t_ramp := dist_to_lim / j_apply; ELSE t_ramp := 0.0; END_IF;
						IF sb &lt;= t_ramp THEN
							IF sb &gt; EPS_TIME THEN sim_p:=sim_p+sim_v*sb+0.5*sim_a*sb*sb+(1.0/6.0)*j_apply*sb*sb*sb; sim_v:=sim_v+sim_a*sb+0.5*j_apply*sb*sb; sim_a:=sim_a+j_apply*sb; END_IF;
						ELSE
							IF t_ramp &gt; EPS_TIME THEN sim_p:=sim_p+sim_v*t_ramp+0.5*sim_a*t_ramp*t_ramp+(1.0/6.0)*j_apply*t_ramp*t_ramp*t_ramp; sim_v:=sim_v+sim_a*t_ramp+0.5*j_apply*t_ramp*t_ramp; sim_a:=sim_a+j_apply*t_ramp; END_IF;
							sim_a:=limit_a; t_hold:=sb-t_ramp;
							IF t_hold &gt; EPS_TIME THEN sim_p:=sim_p+sim_v*t_hold+0.5*sim_a*t_hold*t_hold; sim_v:=sim_v+sim_a*t_hold; END_IF;
						END_IF;
						shape_cnt := FC_S7RTT_BuildProfile(sim_v, sim_a, TargetVel, Limits.fAccMax, Limits.fJerkMax, t_shape_buf, j_shape_buf);
						FOR k:=1 TO shape_cnt DO sim_p:=sim_p+sim_v*t_shape_buf[k]+0.5*sim_a*t_shape_buf[k]*t_shape_buf[k]+(1.0/6.0)*j_shape_buf[k]*t_shape_buf[k]*t_shape_buf[k]*t_shape_buf[k]; sim_v:=sim_v+sim_a*t_shape_buf[k]+0.5*j_shape_buf[k]*t_shape_buf[k]*t_shape_buf[k]; sim_a:=sim_a+j_shape_buf[k]*t_shape_buf[k]; END_FOR;
						fb := sim_p - TargetPos;
						// --- End Eval ---
						
						IF (fb &gt; 0.0 AND fc &gt; 0.0) OR (fb &lt; 0.0 AND fc &lt; 0.0) THEN sc := sa; fc := fa; sd := sb - sa; se := sd; mflag := TRUE; END_IF;
					END_FOR;
					best_t_curr := sb;
					IF ABS(fb) &lt;= SOLVER_COARSE THEN valid_curr := TRUE; END_IF;
				END_IF;
			END_IF;
			
			// Calculate Total Duration for Comparison
			IF valid_curr THEN
				dur_curr := 0.0;
				// Saturated Time
				limit_a := Limits.fAccMax; IF j_apply &lt; 0 THEN limit_a := -Limits.fAccMax; END_IF;
				dist_to_lim := limit_a - c_acc;
				IF (j_apply &gt; 0 AND dist_to_lim &gt; -MATH_EPS) OR (j_apply &lt; 0 AND dist_to_lim &lt; MATH_EPS) THEN t_ramp := dist_to_lim / j_apply; ELSE t_ramp := 0.0; END_IF;
				IF best_t_curr &lt;= t_ramp THEN dur_curr := best_t_curr;
				ELSE dur_curr := best_t_curr; // t_ramp + (t - t_ramp)
				END_IF;
				// Sim to get intermediate state for remaining profile
				sim_p := c_pos; sim_v := c_vel; sim_a := c_acc;
				IF best_t_curr &lt;= t_ramp THEN
					IF best_t_curr &gt; EPS_TIME THEN sim_v:=sim_v+sim_a*best_t_curr+0.5*j_apply*best_t_curr*best_t_curr; sim_a:=sim_a+j_apply*best_t_curr; END_IF;
				ELSE
					IF t_ramp &gt; EPS_TIME THEN sim_v:=sim_v+sim_a*t_ramp+0.5*j_apply*t_ramp*t_ramp; sim_a:=sim_a+j_apply*t_ramp; END_IF;
					sim_a:=limit_a; t_hold:=best_t_curr-t_ramp;
					IF t_hold &gt; EPS_TIME THEN sim_v:=sim_v+sim_a*t_hold; END_IF;
				END_IF;
				shape_cnt := FC_S7RTT_BuildProfile(sim_v, sim_a, TargetVel, Limits.fAccMax, Limits.fJerkMax, t_shape_buf, j_shape_buf);
				FOR k:=1 TO shape_cnt DO dur_curr := dur_curr + t_shape_buf[k]; END_FOR;
				
				// Update Winner
				IF dur_curr &lt; winner_dur THEN winner_dur := dur_curr; winner_t := best_t_curr; winner_j := j_apply; winner_found := TRUE; END_IF;
			END_IF;
		END_FOR;
		
		// Construct Winner
		IF winner_found THEN
			opt_success := TRUE;
			limit_a := Limits.fAccMax; IF winner_j &lt; 0 THEN limit_a := -Limits.fAccMax; END_IF;
			dist_to_lim := limit_a - c_acc;
			IF (winner_j &gt; 0 AND dist_to_lim &gt; -MATH_EPS) OR (winner_j &lt; 0 AND dist_to_lim &lt; MATH_EPS) THEN t_ramp := dist_to_lim / winner_j; ELSE t_ramp := 0.0; END_IF;
			
			IF winner_t &lt;= t_ramp THEN
				IF winner_t &gt; EPS_TIME THEN
					IF SegmentCount &lt; 32 THEN SegmentCount:=SegmentCount+1; Trajectory[SegmentCount].fDuration:=winner_t; Trajectory[SegmentCount].fJerk:=winner_j; END_IF;
					c_pos:=c_pos+c_vel*winner_t+0.5*c_acc*winner_t*winner_t+(1.0/6.0)*winner_j*winner_t*winner_t*winner_t; c_vel:=c_vel+c_acc*winner_t+0.5*winner_j*winner_t*winner_t; c_acc:=c_acc+winner_j*winner_t;
				END_IF;
			ELSE
				IF t_ramp &gt; EPS_TIME THEN
					IF SegmentCount &lt; 32 THEN SegmentCount:=SegmentCount+1; Trajectory[SegmentCount].fDuration:=t_ramp; Trajectory[SegmentCount].fJerk:=winner_j; END_IF;
					c_pos:=c_pos+c_vel*t_ramp+0.5*c_acc*t_ramp*t_ramp+(1.0/6.0)*winner_j*t_ramp*t_ramp*t_ramp; c_vel:=c_vel+c_acc*t_ramp+0.5*winner_j*t_ramp*t_ramp; c_acc:=c_acc+winner_j*t_ramp;
				END_IF;
				c_acc := limit_a; t_hold := winner_t - t_ramp;
				IF t_hold &gt; EPS_TIME THEN
					IF SegmentCount &lt; 32 THEN SegmentCount:=SegmentCount+1; Trajectory[SegmentCount].fDuration:=t_hold; Trajectory[SegmentCount].fJerk:=0.0; END_IF;
					c_pos:=c_pos+c_vel*t_hold+0.5*c_acc*t_hold*t_hold; c_vel:=c_vel+c_acc*t_hold;
				END_IF;
			END_IF;
			shape_cnt := FC_S7RTT_BuildProfile(c_vel, c_acc, TargetVel, Limits.fAccMax, Limits.fJerkMax, t_shape_buf, j_shape_buf);
			FOR i:=1 TO shape_cnt DO IF SegmentCount &lt; 32 THEN SegmentCount:=SegmentCount+1; Trajectory[SegmentCount].fDuration:=t_shape_buf[i]; Trajectory[SegmentCount].fJerk:=j_shape_buf[i]; END_IF; END_FOR;
		END_IF;
	END_IF;

	// ========================================================
	// 2.2 Fallback / Cruise Logic (Original + Cruise)
	// ========================================================
	IF NOT opt_success THEN
		// If dist_req &gt; d_upper, we Cruise at VMax. If &lt; d_lower, at -VMax. 
		// Otherwise, we solve for intermediate peak.
		
		IF dist_req &gt; d_upper + EPS_DIST THEN best_v := Limits.fVelMax;
		ELSIF dist_req &lt; d_lower - EPS_DIST THEN best_v := -Limits.fVelMax;
		ELSE
			// Bisection Solver (Original Logic, compacted)
			sa := -Limits.fVelMax; sb := Limits.fVelMax;
			// Calc Fa/Fb using helper function logic (Dist via profile)
			// Note: Assuming FC_S7RTT_CalcTrajDist calculates distance for a profile peaking at 'sa'/'sb' then going to TargetVel
			fa := FC_S7RTT_CalcTrajDist(sa, c_vel, c_acc, TargetVel, Limits.fAccMax, Limits.fJerkMax) - dist_req;
			fb := FC_S7RTT_CalcTrajDist(sb, c_vel, c_acc, TargetVel, Limits.fAccMax, Limits.fJerkMax) - dist_req;
			
			IF fa * fb &gt; 0.0 THEN IF ABS(fa) &lt; ABS(fb) THEN best_v := sa; ELSE best_v := sb; END_IF;
			ELSE
				sc:=sa; fc:=fa; sd:=sb-sa; se:=sd; mflag:=TRUE;
				FOR iter := 1 TO MAX_ITER DO
					IF ABS(fc) &lt; ABS(fb) THEN sa:=sb; sb:=sc; sc:=sa; fa:=fb; fb:=fc; fc:=fa; END_IF;
					tol1 := 2.0 * SOLVER_EPS * ABS(sb) + 0.5 * SOLVER_TOL; xm := 0.5 * (sc - sb);
					IF ABS(xm) &lt;= tol1 OR fb = 0.0 THEN EXIT; END_IF;
					IF ABS(se) &gt;= tol1 AND ABS(fa) &gt; ABS(fb) THEN
						fCoefS := fb/fa;
						IF sa=sc THEN fCoefP:=2.0*xm*fCoefS; fCoefQ:=1.0-fCoefS; ELSE fCoefQ:=fa/fc; fCoefR:=fb/fc; fCoefP:=fCoefS*(2.0*xm*fCoefQ*(fCoefQ-fCoefR)-(sb-sa)*(fCoefR-1.0)); fCoefQ:=(fCoefQ-1.0)*(fCoefR-1.0)*(fCoefS-1.0); END_IF;
						IF fCoefP &gt; 0.0 THEN fCoefQ:=-fCoefQ; END_IF; fCoefP:=ABS(fCoefP); min1:=3.0*xm*fCoefQ-ABS(tol1*fCoefQ); min2:=ABS(se*fCoefQ);
						IF 2.0*fCoefP &lt; min1 THEN IF mflag THEN IF 2.0*fCoefP &lt; min2 THEN se:=sd; sd:=fCoefP/fCoefQ; mflag:=FALSE; ELSE sd:=xm; se:=sd; mflag:=TRUE; END_IF; ELSE IF 2.0*fCoefP &lt; ABS(sd*fCoefQ) THEN se:=sd; sd:=fCoefP/fCoefQ; mflag:=FALSE; ELSE sd:=xm; se:=sd; mflag:=TRUE; END_IF; END_IF; ELSE sd:=xm; se:=sd; mflag:=TRUE; END_IF;
					ELSE sd:=xm; se:=sd; mflag:=TRUE; END_IF;
					sa:=sb; fa:=fb; IF ABS(sd) &gt; tol1 THEN sb:=sb+sd; ELSE IF xm &gt; 0.0 THEN sb:=sb+tol1; ELSE sb:=sb-tol1; END_IF; END_IF;
					fb := FC_S7RTT_CalcTrajDist(sb, c_vel, c_acc, TargetVel, Limits.fAccMax, Limits.fJerkMax) - dist_req;
					IF (fb &gt; 0.0 AND fc &gt; 0.0) OR (fb &lt; 0.0 AND fc &lt; 0.0) THEN sc:=sa; fc:=fa; sd:=sb-sa; se:=sd; mflag:=TRUE; END_IF;
				END_FOR;
				best_v := sb;
			END_IF;
		END_IF;

		// Generate fallback profile
		shape_cnt := FC_S7RTT_BuildProfile(c_vel, c_acc, best_v, Limits.fAccMax, Limits.fJerkMax, t_shape_buf, j_shape_buf);
		FOR i:=1 TO shape_cnt DO
			IF SegmentCount &lt; 32 THEN SegmentCount:=SegmentCount+1; Trajectory[SegmentCount].fDuration:=t_shape_buf[i]; Trajectory[SegmentCount].fJerk:=j_shape_buf[i]; END_IF;
			c_pos:=c_pos+c_vel*t_shape_buf[i]+0.5*c_acc*t_shape_buf[i]*t_shape_buf[i]+(1.0/6.0)*j_shape_buf[i]*t_shape_buf[i]*t_shape_buf[i]*t_shape_buf[i];
			c_vel:=c_vel+c_acc*t_shape_buf[i]+0.5*j_shape_buf[i]*t_shape_buf[i]*t_shape_buf[i]; c_acc:=c_acc+j_shape_buf[i]*t_shape_buf[i];
		END_FOR;
		// Add Cruise if needed (gap logic)
		c_acc := 0.0; 
		// Sim fwd
		sim_p := c_pos; sim_v := c_vel; sim_a := 0.0;
		shape_cnt := FC_S7RTT_BuildProfile(sim_v, sim_a, TargetVel, Limits.fAccMax, Limits.fJerkMax, t_shape_buf, j_shape_buf);
		FOR k:=1 TO shape_cnt DO sim_p:=sim_p+sim_v*t_shape_buf[k]+0.5*sim_a*t_shape_buf[k]*t_shape_buf[k]+(1.0/6.0)*j_shape_buf[k]*t_shape_buf[k]*t_shape_buf[k]*t_shape_buf[k]; sim_v:=sim_v+sim_a*t_shape_buf[k]+0.5*j_shape_buf[k]*t_shape_buf[k]*t_shape_buf[k]; sim_a:=sim_a+j_shape_buf[k]*t_shape_buf[k]; END_FOR;
		gap := TargetPos - sim_p;
		IF ABS(c_vel) &gt; EPS_VAL AND ABS(gap) &gt; EPS_DIST THEN
			t_cruise := gap / c_vel;
			IF t_cruise &gt; EPS_TIME THEN
				IF SegmentCount &lt; 32 THEN SegmentCount:=SegmentCount+1; Trajectory[SegmentCount].fDuration:=t_cruise; Trajectory[SegmentCount].fJerk:=0.0; END_IF;
				c_pos := c_pos + c_vel * t_cruise;
			END_IF;
		END_IF;
		// Final Decel
		shape_cnt := FC_S7RTT_BuildProfile(c_vel, c_acc, TargetVel, Limits.fAccMax, Limits.fJerkMax, t_shape_buf, j_shape_buf);
		FOR i:=1 TO shape_cnt DO IF SegmentCount &lt; 32 THEN SegmentCount:=SegmentCount+1; Trajectory[SegmentCount].fDuration:=t_shape_buf[i]; Trajectory[SegmentCount].fJerk:=j_shape_buf[i]; END_IF; END_FOR;
	END_IF;
END_IF;

// ========================================================
// 2.5 Trajectory Refinement (Precision Fix)
// ========================================================
IF SegmentCount &gt; 0 AND NOT ModeVelocity THEN
	c_pos := StartState.fPos; c_vel := StartState.fVel; c_acc := StartState.fAcc;
	ref_idx := -1; max_dt := -1.0;
	FOR i := 1 TO SegmentCount DO
		t_rec := Trajectory[i].fDuration; j_restore := Trajectory[i].fJerk;
		IF ABS(j_restore) &lt; MATH_EPS AND ABS(c_acc) &lt; EPS_ACC THEN IF t_rec &gt; max_dt THEN max_dt:=t_rec; ref_idx:=i; v_cruise_start:=c_vel; END_IF; END_IF;
		c_pos:=c_pos+c_vel*t_rec+0.5*c_acc*t_rec*t_rec+(1.0/6.0)*j_restore*t_rec*t_rec*t_rec; c_vel:=c_vel+c_acc*t_rec+0.5*j_restore*t_rec*t_rec; c_acc:=c_acc+j_restore*t_rec;
	END_FOR;
	gap := TargetPos - c_pos;
	IF ref_idx &lt;&gt; -1 AND ABS(gap) &gt; EPS_DIST AND ABS(v_cruise_start) &gt; EPS_VAL THEN
		dt_fix := gap / v_cruise_start;
		Trajectory[ref_idx].fDuration := Trajectory[ref_idx].fDuration + dt_fix;
		IF Trajectory[ref_idx].fDuration &lt; EPS_TIME THEN Trajectory[ref_idx].fDuration := EPS_TIME; END_IF;
	END_IF;
END_IF;

// ========================================================
// 3. Final Pass
// ========================================================
c_pos := StartState.fPos; c_vel := StartState.fVel; c_acc := StartState.fAcc;
FOR i := 1 TO SegmentCount DO
	Trajectory[i].fPos := c_pos; Trajectory[i].fVel := c_vel; Trajectory[i].fAcc := c_acc;
	t_rec := Trajectory[i].fDuration; j_restore := Trajectory[i].fJerk;
	c_pos:=c_pos+c_vel*t_rec+0.5*c_acc*t_rec*t_rec+(1.0/6.0)*j_restore*t_rec*t_rec*t_rec; c_vel:=c_vel+c_acc*t_rec+0.5*j_restore*t_rec*t_rec; c_acc:=c_acc+j_restore*t_rec;
END_FOR;

Done := TRUE;
Done := TRUE;</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>95643a16-59c8-44c0-98a3-4791271629c4</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="FC_S7RTT_AtTime" pouType="function">
        <interface>
          <returnType>
            <derived name="ST_MotionState" />
          </returnType>
          <inputVars>
            <variable name="Trajectory">
              <type>
                <array>
                  <dimension lower="1" upper="32" />
                  <baseType>
                    <derived name="ST_MotionState" />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="SegCount">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="ElapsedTime">
              <type>
                <LREAL />
              </type>
            </variable>
          </inputVars>
          <localVars>
            <variable name="i">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="t_rem">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="t">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="j">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="p0">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="v0">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="a0">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="last_idx">
              <type>
                <INT />
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">IF SegCount &lt;= 0 THEN
    // No trajectory, return first state
    FC_S7RTT_AtTime.fPos := Trajectory[1].fPos; FC_S7RTT_AtTime.fVel := 0.0; FC_S7RTT_AtTime.fAcc := 0.0;
    RETURN;
END_IF;

IF ElapsedTime &lt;= 0.0 THEN
     // Return Initial State from First Segment
     FC_S7RTT_AtTime := Trajectory[1]; 
     FC_S7RTT_AtTime.fDuration := 0.0;
     FC_S7RTT_AtTime.fJerk := 0.0;
     RETURN;
END_IF;

t_rem := ElapsedTime;

FOR i := 1 TO SegCount DO
	IF t_rem &lt;= Trajectory[i].fDuration THEN
		t := t_rem;
		j := Trajectory[i].fJerk;
		// Use pre-calculated state at segment start
		p0 := Trajectory[i].fPos;
		v0 := Trajectory[i].fVel;
		a0 := Trajectory[i].fAcc;

		FC_S7RTT_AtTime.fPos := p0 + v0 * t + 0.5 * a0 * t*t + (1.0/6.0) * j * t*t*t;
		FC_S7RTT_AtTime.fVel := v0 + a0 * t + 0.5 * j * t*t;
		FC_S7RTT_AtTime.fAcc := a0 + j * t;
		FC_S7RTT_AtTime.fJerk := j;
		FC_S7RTT_AtTime.fDuration := 0.0;
		RETURN;
	ELSE
		t_rem := t_rem - Trajectory[i].fDuration;
	END_IF;
END_FOR;

// Time is beyond end of trajectory
// Calculate Final State of last segment
last_idx := SegCount;
t := Trajectory[last_idx].fDuration;
j := Trajectory[last_idx].fJerk;
p0 := Trajectory[last_idx].fPos;
v0 := Trajectory[last_idx].fVel;
a0 := Trajectory[last_idx].fAcc;

p0 := p0 + v0 * t + 0.5 * a0 * t*t + (1.0/6.0) * j * t*t*t;
v0 := v0 + a0 * t + 0.5 * j * t*t;

// Hold Final Position (assuming v=target, a=0 at end)
// Linear projection if Velocity is non-zero
FC_S7RTT_AtTime.fPos := p0 + v0 * t_rem;
FC_S7RTT_AtTime.fVel := v0;
FC_S7RTT_AtTime.fAcc := 0.0;
FC_S7RTT_AtTime.fJerk := 0.0;
FC_S7RTT_AtTime.fDuration := 0.0;</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>3021c349-a048-4635-8ba3-ea39d136f9d6</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="FC_S7RTT_BuildProfile" pouType="function">
        <interface>
          <returnType>
            <INT />
          </returnType>
          <inputVars>
            <variable name="in_v_start">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="in_a_start">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="in_v_target">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="in_a_max">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="in_j_max">
              <type>
                <LREAL />
              </type>
            </variable>
          </inputVars>
          <inOutVars>
            <variable name="out_time">
              <type>
                <array>
                  <dimension lower="1" upper="5" />
                  <baseType>
                    <LREAL />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="out_jerk">
              <type>
                <array>
                  <dimension lower="1" upper="5" />
                  <baseType>
                    <LREAL />
                  </baseType>
                </array>
              </type>
            </variable>
          </inOutVars>
          <localVars>
            <variable name="acc_clamped">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="t_to_zero">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="j_restore">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="v_min_feasible">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="direction">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="v0_mod">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="a0_mod">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="v1_mod">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="t1_max">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="t3_max">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="dv_inflection">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="dv_req">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="dv_missing">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="term">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="a_peak">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="t1">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="t2">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="t3">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="cnt">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="EPS">
              <type>
                <LREAL />
              </type>
              <initialValue>
                <simpleValue value="1E-10" />
              </initialValue>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">cnt := 0;

// 1. Clamp initial acceleration to limits
acc_clamped := in_a_start;
IF acc_clamped &gt; in_a_max THEN acc_clamped := in_a_max; END_IF;
IF acc_clamped &lt; -in_a_max THEN acc_clamped := -in_a_max; END_IF;

// 2. Check feasibility (can we stop?)
t_to_zero := ABS(acc_clamped) / in_j_max;
IF ABS(acc_clamped) &gt; EPS THEN
    IF acc_clamped &gt; 0.0 THEN j_restore := -in_j_max; ELSE j_restore := in_j_max; END_IF;
ELSE
    j_restore := 0.0;
END_IF;

v_min_feasible := in_v_start + acc_clamped * t_to_zero + 0.5 * j_restore * t_to_zero * t_to_zero;

// 3. Determine direction
direction := 1.0;
IF in_v_target &lt; v_min_feasible - EPS THEN
    direction := -1.0;
END_IF;

// 4. Normalize to positive quadrant
v0_mod := in_v_start * direction;
a0_mod := acc_clamped * direction;
v1_mod := in_v_target * direction;

t1_max := (in_a_max - a0_mod) / in_j_max;
IF t1_max &lt; 0.0 THEN t1_max := 0.0; END_IF;

t3_max := in_a_max / in_j_max;

// Velocity change at inflection (max accel reached)
dv_inflection := (a0_mod * t1_max + 0.5 * in_j_max * t1_max * t1_max) +
                 (in_a_max * t3_max - 0.5 * in_j_max * t3_max * t3_max);

dv_req := v1_mod - v0_mod;

// 5. Calculate profile times
IF dv_req &gt; dv_inflection THEN
    // Trapezoidal (Constant Acceleration Phase)
    dv_missing := dv_req - dv_inflection;
    t2 := dv_missing / in_a_max;
    t1 := t1_max;
    t3 := t3_max;
ELSE
    // Triangular (No Constant Acceleration)
    term := in_j_max * dv_req + 0.5 * a0_mod * a0_mod;
    IF term &lt; 0.0 THEN term := 0.0; END_IF;
    a_peak := SQRT(term);
    
    t1 := (a_peak - a0_mod) / in_j_max;
    IF t1 &lt; 0.0 THEN t1 := 0.0; END_IF;
    
    t3 := a_peak / in_j_max;
    IF t3 &lt; 0.0 THEN t3 := 0.0; END_IF;
    
    t2 := 0.0;
END_IF;

// 6. Output Segments
IF t1 &gt; EPS THEN
    cnt := cnt + 1; out_time[cnt] := t1; out_jerk[cnt] := direction * in_j_max;
END_IF;
IF t2 &gt; EPS THEN
    cnt := cnt + 1; out_time[cnt] := t2; out_jerk[cnt] := 0.0;
END_IF;
IF t3 &gt; EPS THEN
    cnt := cnt + 1; out_time[cnt] := t3; out_jerk[cnt] := -direction * in_j_max;
END_IF;

FC_S7RTT_BuildProfile := cnt;</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>52f0419d-84c7-4f14-92ea-d17f1133d6cf</ObjectId>
          </data>
        </addData>
      </pou>
      <pou name="FC_S7RTT_CalcTrajDist" pouType="function">
        <interface>
          <returnType>
            <LREAL />
          </returnType>
          <inputVars>
            <variable name="v_peak">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="start_v">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="start_a">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="target_v">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="a_max">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="j_max">
              <type>
                <LREAL />
              </type>
            </variable>
          </inputVars>
          <localVars>
            <variable name="t_buf">
              <type>
                <array>
                  <dimension lower="1" upper="5" />
                  <baseType>
                    <LREAL />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="j_buf">
              <type>
                <array>
                  <dimension lower="1" upper="5" />
                  <baseType>
                    <LREAL />
                  </baseType>
                </array>
              </type>
            </variable>
            <variable name="cnt">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="i">
              <type>
                <INT />
              </type>
            </variable>
            <variable name="v_curr">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="a_curr">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="dist_total">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="t_seg">
              <type>
                <LREAL />
              </type>
            </variable>
            <variable name="j_seg">
              <type>
                <LREAL />
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">dist_total := 0.0;
v_curr := start_v;
a_curr := start_a;

// Phase 1: Start -&gt; Peak Velocity
cnt := FC_S7RTT_BuildProfile(v_curr, a_curr, v_peak, a_max, j_max, t_buf, j_buf);
FOR i := 1 TO cnt DO
	t_seg := t_buf[i];
	j_seg := j_buf[i];
    // Standard kinematic integration: p = p0 + v0*t + 0.5*a0*t^2 + 1/6*j*t^3
	dist_total := dist_total + v_curr * t_seg + 0.5 * a_curr * t_seg*t_seg + (1.0/6.0) * j_seg * t_seg*t_seg*t_seg;
	v_curr := v_curr + a_curr * t_seg + 0.5 * j_seg * t_seg*t_seg;
	a_curr := a_curr + j_seg * t_seg;
END_FOR;

// Phase 2: Peak Velocity -&gt; Target Velocity
cnt := FC_S7RTT_BuildProfile(v_curr, a_curr, target_v, a_max, j_max, t_buf, j_buf);
FOR i := 1 TO cnt DO
	t_seg := t_buf[i];
	j_seg := j_buf[i];
	dist_total := dist_total + v_curr * t_seg + 0.5 * a_curr * t_seg*t_seg + (1.0/6.0) * j_seg * t_seg*t_seg*t_seg;
	v_curr := v_curr + a_curr * t_seg + 0.5 * j_seg * t_seg*t_seg;
	a_curr := a_curr + j_seg * t_seg;
END_FOR;

FC_S7RTT_CalcTrajDist := dist_total;</xhtml>
          </ST>
        </body>
        <addData>
          <data name="http://www.3s-software.com/plcopenxml/objectid" handleUnknown="discard">
            <ObjectId>ee9c0a18-4d98-4537-bacd-83584f252238</ObjectId>
          </data>
        </addData>
      </pou>
    </pous>
  </types>
  <instances>
    <configurations />
  </instances>
  <addData>
    <data name="http://www.3s-software.com/plcopenxml/projectstructure" handleUnknown="discard">
      <ProjectStructure>
        <Folder Name="S7RTT">
          <Object Name="FB_S7RTT_OTG" ObjectId="a4ba0152-5153-418a-8491-262185d3062f" />
          <Object Name="FB_S7RTT_Plan" ObjectId="95643a16-59c8-44c0-98a3-4791271629c4" />
          <Object Name="FC_S7RTT_AtTime" ObjectId="3021c349-a048-4635-8ba3-ea39d136f9d6" />
          <Object Name="FC_S7RTT_BuildProfile" ObjectId="52f0419d-84c7-4f14-92ea-d17f1133d6cf" />
          <Object Name="FC_S7RTT_CalcTrajDist" ObjectId="ee9c0a18-4d98-4537-bacd-83584f252238" />
          <Object Name="ST_MotionLimits" ObjectId="d3412a66-ab42-4656-b5ac-8ceac29439de" />
          <Object Name="ST_MotionState" ObjectId="093654ef-94b9-49f9-9c6c-4acf457e8661" />
        </Folder>
      </ProjectStructure>
    </data>
  </addData>
</project>